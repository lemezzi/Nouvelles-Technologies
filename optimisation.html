<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="utf-8">
    <title>Optimisation Temporelle et Complexité Algorithmique</title>
    <meta content="width=device-width, initial-scale=1.0" name="viewport">
    <meta content="Optimisation, Algorithmes, Complexité, Performance, Big O" name="keywords">
    <meta content="Guide complet sur l'optimisation temporelle, la complexité algorithmique et les méthodes pour améliorer l'efficacité du code" name="description">

    <!-- Favicon -->
    <link href="img/favicon.ico" rel="icon">

    <!-- Google Web Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700;800&family=Rubik:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Icon Font Stylesheet -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.10.0/css/all.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.4.1/font/bootstrap-icons.css" rel="stylesheet">

    <!-- Libraries Stylesheet -->
    <link href="lib/owlcarousel/assets/owl.carousel.min.css" rel="stylesheet">
    <link href="lib/animate/animate.min.css" rel="stylesheet">

    <!-- Customized Bootstrap Stylesheet -->
    <link href="css/bootstrap.min.css" rel="stylesheet">

    <!-- Template Stylesheet -->
    <link href="css/style.css" rel="stylesheet">
</head>

<body>
    <!-- Spinner Start -->

    <!-- Navbar Start -->
    <div class="container-fluid position-relative p-0">
        <nav class="navbar navbar-expand-lg navbar-dark px-5 py-3 py-lg-0">
            <a href="index.html" class="navbar-brand p-0">
                <h1 class="m-0">
                    <i class="fa fa-user-tie me-2"></i>
                    Clean  & <span style="color: green;">Green</span> code
                  </h1>
                              </a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse">
                <span class="fa fa-bars"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarCollapse">
                <div class="navbar-nav ms-auto py-0">
                    <a href="index.html" class="nav-item nav-link ">Home</a>
                    <a href="detail.html" class="nav-item nav-link">Pourquoi?</a>

                    <a href="blog.html" class="nav-item nav-link">Sources</a>

                    <a href="optimisation.html" class="nav-item nav-link active">Optimisation</a>
                   
                 
                </div>
                <a href="pdf/veille.pdf" class="btn btn-primary py-2 px-4 ms-3" target="_blank">
                    Télécharger la présentation
                  </a>            </div>
        </nav>

        <div class="container-fluid bg-primary py-5 bg-header" style="margin-bottom: 90px;">
            <div class="row py-5">
                <div class="col-12 pt-lg-5 mt-lg-5 text-center">
                    <h1 class="display-4 text-white animated zoomIn">Optimisation temporelle : la clé des algorithmes performants</h1>
                </div>
            </div>
        </div>
    </div>
    <!-- Navbar End -->

    <!-- Full Screen Search Start -->
    <div class="modal fade" id="searchModal" tabindex="-1">
        <div class="modal-dialog modal-fullscreen">
            <div class="modal-content" style="background: rgba(9, 30, 62, .7);">
                <div class="modal-header border-0">
                    <button type="button" class="btn bg-white btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body d-flex align-items-center justify-content-center">
                    <div class="input-group" style="max-width: 600px;">
                        <input type="text" class="form-control bg-transparent border-primary p-3" placeholder="Rechercher...">
                        <button class="btn btn-primary px-4"><i class="bi bi-search"></i></button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <!-- Full Screen Search End -->

    <!-- Blog Start -->
    <div class="container-fluid py-5 wow fadeInUp" data-wow-delay="0.1s">
        <div class="container py-5">
            <div class="row g-5">
                <div class="col-lg-8">
                    <!-- Blog Detail Start -->
                    <div class="mb-5">
                        <img class="img-fluid w-100 rounded mb-5" src="img/image3.png" alt="Graphique de complexité algorithmique">
                        <h1 class="mb-4"><strong>L'optimisation temporelle et la complexité algorithmique : fondements d'un code efficace</strong></h1>
                        <p><strong>L'optimisation temporelle</strong> est une dimension cruciale du développement logiciel qui vise à réduire le temps d'exécution des programmes. Cette optimisation repose fortement sur la compréhension de la <strong>complexité algorithmique</strong>, qui mesure l'efficacité des algorithmes en fonction de la taille des données d'entrée. Dans un monde où les applications traitent des volumes de données toujours plus importants, maîtriser ces concepts est devenu indispensable pour tout développeur soucieux de créer des solutions performantes.</p>

                        <h3><strong>1. Les notations de complexité : comprendre et maîtriser le Big O</strong></h3>
                        <p>La <strong>notation Big O</strong> est le standard universellement reconnu pour exprimer la complexité algorithmique. Elle décrit la limite supérieure du temps d'exécution ou de l'espace mémoire requis par un algorithme en fonction de la taille des données (généralement notée n).</p>
                        
                        <div class="bg-light p-4 mb-4 rounded">
                            <h5>Les principales classes de complexité :</h5>
                            <ul>
                                <li><code>O(1)</code> - <strong>Complexité constante</strong> : L'algorithme s'exécute en temps constant quelle que soit la taille des données. Exemples : accès à un élément d'un tableau par son index, insertion en tête d'une liste chaînée.</li>
                                <li><code>O(log n)</code> - <strong>Complexité logarithmique</strong> : L'algorithme divise le problème en parties plus petites à chaque étape. Exemples : recherche binaire, opérations sur des arbres binaires équilibrés (AVL, Red-Black).</li>
                                <li><code>O(n)</code> - <strong>Complexité linéaire</strong> : Le temps d'exécution croît proportionnellement à la taille des données. Exemples : parcours de tableaux, recherche séquentielle.</li>
                                <li><code>O(n log n)</code> - <strong>Complexité quasi-linéaire</strong> : Caractéristique des algorithmes de tri efficaces. Exemples : tri fusion, tri rapide (cas moyen), tri par tas.</li>
                                <li><code>O(n²)</code> - <strong>Complexité quadratique</strong> : Performance qui se dégrade rapidement avec la taille des données. Exemples : tri à bulles, tri par insertion, comparaison de tous les éléments d'un ensemble deux à deux.</li>
                                <li><code>O(n³)</code> - <strong>Complexité cubique</strong> : Rencontrée dans certains algorithmes matriciels naïfs. Exemple : multiplication de matrices sans optimisation.</li>
                                <li><code>O(2^n)</code> - <strong>Complexité exponentielle</strong> : Généralement impraticable pour de grandes entrées. Exemples : résolution naïve du problème du voyageur de commerce, calcul récursif de la suite de Fibonacci.</li>
                            </ul>
                        </div>
                        
                        <p>Comprendre ces notations permet d'évaluer l'efficacité relative des algorithmes et de prédire comment ils se comporteront face à des ensembles de données de différentes tailles.</p>
                        
                        <div class="table-responsive mb-4">
                            <table class="table table-bordered">
                                <thead class="bg-primary text-white">
                                    <tr>
                                        <th>Complexité</th>
                                        <th>n=10</th>
                                        <th>n=100</th>
                                        <th>n=1000</th>
                                        <th>n=10000</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td><code>O(1)</code></td>
                                        <td>1</td>
                                        <td>1</td>
                                        <td>1</td>
                                        <td>1</td>
                                    </tr>
                                    <tr>
                                        <td><code>O(log n)</code></td>
                                        <td>3</td>
                                        <td>7</td>
                                        <td>10</td>
                                        <td>13</td>
                                    </tr>
                                    <tr>
                                        <td><code>O(n)</code></td>
                                        <td>10</td>
                                        <td>100</td>
                                        <td>1,000</td>
                                        <td>10,000</td>
                                    </tr>
                                    <tr>
                                        <td><code>O(n log n)</code></td>
                                        <td>30</td>
                                        <td>700</td>
                                        <td>10,000</td>
                                        <td>130,000</td>
                                    </tr>
                                    <tr>
                                        <td><code>O(n²)</code></td>
                                        <td>100</td>
                                        <td>10,000</td>
                                        <td>1,000,000</td>
                                        <td>100,000,000</td>
                                    </tr>
                                    <tr>
                                        <td><code>O(2^n)</code></td>
                                        <td>1,024</td>
                                        <td>1.27×10<sup>30</sup></td>
                                        <td>1.07×10<sup>301</sup></td>
                                        <td>Trop grand</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        
                        <p>Ce tableau illustre l'impact dramatique de la complexité sur les performances. Pour un algorithme exponentiel, même un ensemble de données modeste (n=100) devient intraitable, tandis qu'un algorithme logarithmique reste efficace même avec des millions d'éléments.</p>
                        
                        <h3><strong>2. Analyse et mesure de la complexité temporelle</strong></h3>
                        
                        <p>L'analyse de la complexité algorithmique peut être réalisée de plusieurs façons complémentaires :</p>
                        
                        <h4>2.1 Analyse théorique</h4>
                        <p>L'analyse théorique consiste à examiner la structure de l'algorithme pour déterminer sa complexité mathématique :</p>
                        <ul>
                            <li><strong>Comptage des opérations élémentaires</strong> : identifier les instructions qui dominent le temps d'exécution</li>
                            <li><strong>Analyse des boucles et de la récursion</strong> : déterminer combien de fois chaque portion de code est exécutée</li>
                            <li><strong>Formulation d'équations de récurrence</strong> : pour les algorithmes récursifs, établir des formules mathématiques qui modélisent leur comportement</li>
                        </ul>
                        
                        <div class="bg-light p-4 mb-4 rounded">
                            <h5>Exemple d'analyse théorique :</h5>
                            <pre class="bg-dark text-white p-3 rounded">
# Analyse d'un algorithme de recherche séquentielle
def recherche_sequentielle(tableau, cible):
    for i in range(len(tableau)):  # Cette boucle s'exécute au maximum n fois
        if tableau[i] == cible:    # Comparaison: opération O(1)
            return i               # Retour immédiat si trouvé
    return -1                      # Si non trouvé, retourne -1

# Complexité temporelle: O(n) dans le pire cas (élément non trouvé ou en dernière position)
# Complexité spatiale: O(1) car aucun espace supplémentaire proportionnel à l'entrée n'est utilisé
                            </pre>
                        </div>
                        
                        <h4>2.2 Profilage et mesure empirique</h4>
                        <p>Le profilage consiste à mesurer concrètement les performances d'un algorithme pendant son exécution :</p>
                        <ul>
                            <li><strong>Outils de profilage</strong> : utilisation d'outils comme Python's cProfile, Java's JProfiler, ou les Chrome DevTools pour JavaScript</li>
                            <li><strong>Benchmarking</strong> : exécution de tests de performance avec différentes tailles d'entrée pour observer l'évolution du temps d'exécution</li>
                            <li><strong>Visualisation des résultats</strong> : représentation graphique de la relation entre la taille des données et le temps d'exécution</li>
                        </ul>
                        
                        <div class="bg-light p-4 mb-4 rounded">
                            <h5>Exemple de code de benchmarking en Python :</h5>
                            <pre class="bg-dark text-white p-3 rounded">
import time
import matplotlib.pyplot as plt
import numpy as np

def mesurer_performance(fonction, tailles, *args):
    temps = []
    for taille in tailles:
        # Générer des données de test
        donnees_test = np.random.randint(0, 1000, size=taille)
        
        # Mesurer le temps d'exécution
        debut = time.time()
        fonction(donnees_test, *args)
        fin = time.time()
        
        temps.append(fin - debut)
    
    # Tracer la courbe de performance
    plt.figure(figsize=(10, 6))
    plt.plot(tailles, temps, marker='o')
    plt.title(f"Performance de {fonction.__name__}")
    plt.xlabel("Taille des données (n)")
    plt.ylabel("Temps d'exécution (secondes)")
    plt.grid(True)
    plt.savefig(f"{fonction.__name__}_performance.png")
    plt.show()
                            </pre>
                        </div>
                        
                        <h3><strong>3. Stratégies d'optimisation et réduction de la complexité</strong></h3>
                        
                        <p>L'amélioration des performances temporelles peut être réalisée à travers plusieurs approches :</p>
                        
                        <h4>3.1 Choix des structures de données appropriées</h4>
                        <p>Le choix de la structure de données peut radicalement changer la complexité d'un algorithme :</p>
                        
                        <div class="table-responsive mb-4">
                            <table class="table table-bordered">
                                <thead class="bg-primary text-white">
                                    <tr>
                                        <th>Structure de données</th>
                                        <th>Accès</th>
                                        <th>Recherche</th>
                                        <th>Insertion</th>
                                        <th>Suppression</th>
                                        <th>Cas d'utilisation optimal</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>Tableau (Array)</td>
                                        <td>O(1)</td>
                                        <td>O(n)</td>
                                        <td>O(n)</td>
                                        <td>O(n)</td>
                                        <td>Accès aléatoire rapide, taille fixe</td>
                                    </tr>
                                    <tr>
                                        <td>Liste chaînée</td>
                                        <td>O(n)</td>
                                        <td>O(n)</td>
                                        <td>O(1)*</td>
                                        <td>O(1)*</td>
                                        <td>Insertions/suppressions fréquentes</td>
                                    </tr>
                                    <tr>
                                        <td>Table de hachage</td>
                                        <td>N/A</td>
                                        <td>O(1) moyenne</td>
                                        <td>O(1) moyenne</td>
                                        <td>O(1) moyenne</td>
                                        <td>Recherches rapides par clé</td>
                                    </tr>
                                    <tr>
                                        <td>Arbre binaire de recherche</td>
                                        <td>N/A</td>
                                        <td>O(log n)**</td>
                                        <td>O(log n)**</td>
                                        <td>O(log n)**</td>
                                        <td>Données ordonnées, recherches efficaces</td>
                                    </tr>
                                    <tr>
                                        <td>Tas (Heap)</td>
                                        <td>O(1) pour max/min</td>
                                        <td>O(n)</td>
                                        <td>O(log n)</td>
                                        <td>O(log n)</td>
                                        <td>Files de priorité, tri par tas</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="small">* Si position connue | ** Si arbre équilibré</p>
                        
                        <div class="bg-light p-4 mb-4 rounded">
                            <h5>Exemple d'optimisation par changement de structure de données :</h5>
                            <pre class="bg-dark text-white p-3 rounded">
# Avant optimisation: O(n²) en utilisant des listes
def trouver_doublons_naif(nombres):
    doublons = []
    for i in range(len(nombres)):
        for j in range(i+1, len(nombres)):
            if nombres[i] == nombres[j] and nombres[i] not in doublons:
                doublons.append(nombres[i])
    return doublons

# Après optimisation: O(n) en utilisant un ensemble (set)
def trouver_doublons_optimise(nombres):
    vus = set()
    doublons = set()
    for nombre in nombres:
        if nombre in vus:
            doublons.add(nombre)
        else:
            vus.add(nombre)
    return list(doublons)
                            </pre>
                        </div>
                        
                        <h4>3.2 Techniques algorithmiques avancées</h4>
                        <p>Plusieurs approches algorithmiques peuvent réduire significativement la complexité temporelle :</p>
                        
                        <h5>3.2.1 Diviser pour régner (Divide and Conquer)</h5>
                        <p>Cette approche consiste à diviser récursivement un problème en sous-problèmes plus petits, à résoudre ces sous-problèmes indépendamment, puis à combiner leurs solutions.</p>
                        <div class="bg-light p-4 mb-4 rounded">
                            <p><strong>Avantages :</strong></p>
                            <ul>
                                <li>Réduit souvent la complexité (ex: passage de O(n²) à O(n log n) pour le tri)</li>
                                <li>Favorise la parallélisation des calculs</li>
                                <li>Permet de traiter efficacement des problèmes récursifs</li>
                            </ul>
                            <p><strong>Exemple d'algorithmes :</strong> Tri fusion (Merge Sort), Tri rapide (Quick Sort), recherche binaire, algorithme de Karatsuba pour la multiplication</p>
                        </div>
                        
                        <h5>3.2.2 Programmation dynamique</h5>
                        <p>Technique d'optimisation qui résout des problèmes complexes en les décomposant en sous-problèmes plus simples et en mémorisant leurs solutions pour éviter les calculs redondants.</p>
                        <div class="bg-light p-4 mb-4 rounded">
                            <p><strong>Avantages :</strong></p>
                            <ul>
                                <li>Réduit drastiquement la complexité pour certains problèmes (passage de O(2^n) à O(n²) ou O(n))</li>
                                <li>Particulièrement efficace pour les problèmes d'optimisation combinatoire</li>
                                <li>Permet de résoudre des problèmes qui seraient intraitables avec une approche naïve</li>
                            </ul>
                            <p><strong>Exemple d'applications :</strong> Problème du sac à dos, plus longue sous-séquence commune, calcul du nombre de Fibonacci</p>
                            
                            <h6>Exemple: Calcul de Fibonacci avec programmation dynamique</h6>
                            <pre class="bg-dark text-white p-3 rounded">
# Approche naïve récursive: O(2^n)
def fibonacci_recursif(n):
    if n <= 1:
        return n
    return fibonacci_recursif(n-1) + fibonacci_recursif(n-2)

# Approche avec programmation dynamique: O(n)
def fibonacci_dynamique(n):
    if n <= 1:
        return n
    
    # Initialisation de la table de mémorisation
    fib = [0] * (n+1)
    fib[1] = 1
    
    # Remplissage de la table de bas en haut
    for i in range(2, n+1):
        fib[i] = fib[i-1] + fib[i-2]
    
    return fib[n]
                            </pre>
                        </div>
                        
                        <h5>3.2.3 Memoization</h5>
                        <p>Technique spécifique de programmation dynamique qui consiste à mémoriser les résultats des appels de fonction pour éviter de recalculer les mêmes valeurs.</p>
                        <div class="bg-light p-4 mb-4 rounded">
                            <pre class="bg-dark text-white p-3 rounded">
# Fonction de memoization générique
def memoize(func):
    cache = {}
    def wrapper(*args):
        if args not in cache:
            cache[args] = func(*args)
        return cache[args]
    return wrapper

# Application à Fibonacci
@memoize
def fibonacci_memoize(n):
    if n <= 1:
        return n
    return fibonacci_memoize(n-1) + fibonacci_memoize(n-2)

# Cette version a une complexité effective de O(n) au lieu de O(2^n)
                            </pre>
                        </div>
                        
                        <h5>3.2.4 Algorithmes gloutons (Greedy Algorithms)</h5>
                        <p>Approche qui consiste à faire, à chaque étape, le choix localement optimal dans l'espoir d'atteindre un optimum global.</p>
                        <div class="bg-light p-4 mb-4 rounded">
                            <p><strong>Avantages :</strong></p>
                            <ul>
                                <li>Généralement simples à concevoir et à implémenter</li>
                                <li>Souvent très efficaces en termes de complexité temporelle</li>
                                <li>Peuvent fournir des solutions approximatives à des problèmes NP-complets</li>
                            </ul>
                            <p><strong>Exemple d'applications :</strong> Algorithme de Dijkstra, codage de Huffman, problème du rendu de monnaie</p>
                        </div>
                        
                        <h3><strong>4. Optimisations spécifiques aux langages et environnements</strong></h3>
                        
                        <p>Au-delà des optimisations algorithmiques, chaque langage et environnement offre des opportunités spécifiques :</p>
                        
                        <h4>4.1 Optimisations pour les langages à haut niveau</h4>
                        <div class="mb-4">
                            <h5>Python</h5>
                            <ul>
                                <li><strong>Utilisation des collections spécialisées</strong> : <code>collections.deque</code> pour les files, <code>collections.Counter</code> pour compter des occurrences</li>
                                <li><strong>List comprehensions</strong> : plus rapides que les boucles for traditionnelles</li>
                                <li><strong>Générateurs</strong> : économie de mémoire pour les séquences de grande taille</li>
                                <li><strong>Numba</strong> : compilation JIT pour les calculs numériques intensifs</li>
                                <li><strong>NumPy</strong> : opérations vectorisées sur les tableaux beaucoup plus rapides que les boucles Python</li>
                            </ul>
                            
                            <h5>JavaScript</h5>
                            <ul>
                                <li><strong>Éviter les modifications du DOM</strong> : regrouper les modifications pour réduire les reflows</li>
                                <li><strong>Délégation d'événements</strong> : attacher des écouteurs à des éléments parents plutôt qu'à chaque enfant</li>
                                <li><strong>WebWorkers</strong> : utilisation du multithreading pour les tâches intensives</li>
                                <li><strong>Array.prototype.map/filter/reduce</strong> : optimisés par le moteur JavaScript</li>
                            </ul>
                            
                            <h5>Java</h5>
                            <ul>
                                <li><strong>Réutilisation des objets</strong> : éviter la création excessive d'objets temporaires</li>
                                <li><strong>StringBuilder</strong> : pour la concaténation efficace de chaînes</li>
                                <li><strong>Stream API</strong> : opérations fonctionnelles optimisées sur les collections</li>
                                <li><strong>Parallel Streams</strong> : parallélisation automatique des opérations sur les collections</li>
                            </ul>
                        </div>
                        
                        <h4>4.2 Parallélisation et calcul distribué</h4>
                        <p>Pour les problèmes de grande taille, la parallélisation peut offrir des gains de performance significatifs :</p>
                        <ul>
                            <li><strong>Multithreading</strong> : division du travail entre plusieurs threads sur un seul processeur</li>
                            <li><strong>Calcul GPU</strong> : utilisation des processeurs graphiques pour des calculs massivement parallèles (CUDA, OpenCL)</li>
                            <li><strong>Calcul distribué</strong> : répartition des tâches sur plusieurs machines (Hadoop, Spark)</li>
                            <li><strong>Algorithmes parallèles</strong> : conception d'algorithmes spécifiquement adaptés à l'exécution parallèle</li>
                        </ul>
                        
                        <div class="bg-light p-4 mb-4 rounded">
                            <h5>Exemple de parallélisation en Python avec concurrent.futures :</h5>
                            <pre class="bg-dark text-white p-3 rounded">
import concurrent.futures
import math

def est_premier(n):
    if n < 2:
        return False
    for i in range(2, int(math.sqrt(n)) + 1):
        if n % i == 0:
            return False
    return True

# Version séquentielle
def trouver_premiers_sequentiel(debut, fin):
    return [n for n in range(debut, fin) if est_premier(n)]

# Version parallèle
def trouver_premiers_parallele(debut, fin, max_workers=None):
    premiers = []
    with concurrent.futures.ProcessPoolExecutor(max_workers=max_workers) as executor:
        # Mapper la fonction est_premier sur chaque nombre
        futures = {executor.submit(est_premier, n): n for n in range(debut, fin)}
        for future in concurrent.futures.as_completed(futures):
            n = futures[future]
            if future.result():
                premiers.append(n)
    return sorted(premiers)
                            </pre>
                            
                        </div>

                        </div>
                        
                        </div>
                        
                        <div class="col-lg-4">
                            <!-- Category Start -->
                            <div class="mb-5 wow slideInUp" data-wow-delay="0.1s">
                                <div class="section-title section-title-sm position-relative pb-3 mb-4">
                                    <h3 class="mb-0">Catégories</h3>
                                </div>
                                <div class="link-animated d-flex flex-column justify-content-start">
                                    <a class="h5 fw-semi-bold bg-light rounded py-2 px-3 mb-2" href="#">Gestion du Temps</a>
                                    <a class="h5 fw-semi-bold bg-light rounded py-2 px-3 mb-2" href="#">Performance Algorithmique</a>
                                    <a class="h5 fw-semi-bold bg-light rounded py-2 px-3 mb-2" href="#">Développement Efficace</a>
                                    <a class="h5 fw-semi-bold bg-light rounded py-2 px-3 mb-2" href="#">Optimisation Temporelle</a>
                                </div>
                            </div>
                            <!-- Category End -->
                        
                            <!-- Tags Start -->
                            <div class="mb-5 wow slideInUp" data-wow-delay="0.1s">
                                <div class="section-title section-title-sm position-relative pb-3 mb-4">
                                    <h3 class="mb-0">Mots-clés</h3>
                                </div>
                                <div class="d-flex flex-wrap m-n1">
                                    <a href="#" class="btn btn-light m-1">Temps de Réponse</a>
                                    <a href="#" class="btn btn-light m-1">Algorithmes Rapides</a>
                                    <a href="#" class="btn btn-light m-1">Productivité</a>
                                    <a href="#" class="btn btn-light m-1">Performance</a>
                                    <a href="#" class="btn btn-light m-1">Délais Réduits</a>
                                </div>
                            </div>
                            <!-- Tags End -->
                        
                            <div class="wow slideInUp" data-wow-delay="0.1s">
                                <h1 class="m-0">
                                    Fast & <span style="color: #007bff;">Efficient</span> Code
                                </h1>
                                <div class="bg-light text-center" style="padding: 30px;">
                                    <p>Optimiser le temps d’exécution du code et la productivité des développeurs, c’est garantir des logiciels plus performants, réactifs et adaptés aux besoins modernes. L’optimisation temporelle est une clé pour délivrer rapidement sans sacrifier la qualité.</p>
                                    <a href="#" class="btn btn-primary py-2 px-4">Découvrir plus</a>
                                </div>
                            </div>
                        </div>
                        </div>
                    </div>

                    </div>
                    <!-- Footer Start -->
<footer class="container-fluid bg-dark text-light mt-5">
 
    <div class="container-fluid text-center py-3" style="background: #061429;">
        <small class="text-white-50">
            &copy; 2025 GreenCode. Designed for efficiency and sustainability.
        </small>
    </div>
</footer>
<!-- Footer End -->



                        


                        
                        
                     